# What challenges did you face while building this?
Building the Library Management API posed several challenges. The Windows + OneDrive setup caused Uvicorn reload issues, `.env` load failures, and `DATABASE_URL=None` errors. Schema drift after adding `created_at` led to PostgreSQL `ProgrammingError`s, requiring careful migrations. Authentication issues included bcrypt’s 72-byte limit, duplicate `Bearer` tokens, and missing Swagger auth locks due to misconfigured `OAuth2PasswordBearer`. Async pitfalls like `MissingGreenlet` and pool misconfigurations added complexity. Through detailed traceback analysis, JWT inspection, and schema validation, each problem was resolved, resulting in a stable, production-ready API.


# How did you solve them?
I solved the challenges systematically: moved the project out of OneDrive to avoid file-locking issues; used explicit `.env` loading and `--no-reload` to stabilize startup; fixed schema mismatches by dropping and recreating tables during development; handled `IntegrityError` for duplicate emails/users with user-friendly 400 responses; truncated passwords to 72 bytes to comply with bcrypt; ensured JWT auth worked by using `OAuth2PasswordBearer` and correctly formatting the `Authorization: Bearer <token>` header; and added a custom OpenAPI schema to enforce auth visibility in Swagger UI. Each fix was validated through logging, `jwt.io`, and targeted testing.

# What would you do differently if you had more time?
If I had more time, I would implement **Alembic migrations** to manage schema changes safely, add comprehensive **pytest-based async tests** for all endpoints, integrate **rate limiting and refresh tokens** for enhanced security, and build a simple **React frontend** to demonstrate full-stack functionality. I’d also containerize the app with **Docker** and deploy it to a free-tier platform like **Render** for real-world validation — turning this robust API into a production-ready system.

# What did you learn from this assignment?
From this assignment, I learned how to design and implement a secure, production-grade FastAPI backend with async SQLAlchemy, JWT authentication, and PostgreSQL integration. I gained deep insight into common pitfalls—like environment-specific issues on Windows, bcrypt’s 72-byte limit, and ORM schema drift—and how to systematically debug them using logs, tracebacks, and tools like jwt.io. Most importantly, I realized that robust APIs require not just functionality, but defensive practices: proper error handling, input validation, response models without sensitive data, and clear documentation—turning a working prototype into a maintainable system.